import csv

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import seaborn as sns

from logic import merops_connector

# Ensure that Pandas always loads full sequence.
pd.set_option('max_colwidth', 1000000)

# General Seaborn aesthetics
sns.set(font='monospace')

########################################################################
# MAPS SINGLE-LETTER CATALYTIC TYPE CODES FROM MEROPS IDs TO DESCRIPTIVE
# CATALYTIC TYPE NAMES. ONLY USED FOR GENERATION OF LABELS ON PLOTS.
########################################################################
CATALYTIC_TYPES = {
    'A':'Aspartic',
    'C':'Cysteine',
    'G':'Glutamic',
    'M':'Metallo',
    'N':'Asparagine',
    'P':'Mixed',
    'S':'Serine',
    'T':'Threonine',
    'U':'Unknown',
}
########################################################################


def generate_position_labels(sequence_df):
    """
    Generate label string for pattern postions in y-ticks of protease
        pattern heatmap.

    Parameters:
        sequence_df -- Pandas DataFrame.

    Returns:
        position_labels
    """

    position_labels = []
    for i, position_label in enumerate(sequence_df.columns.tolist()):
        position_labels.append(position_label.center(5))
        # Add vert bar for cleavage site if even-width sequences.
        if i == ((len(sequence_df.columns) / 2) - 1):
            position_labels.append('|'.center(5))
    position_labels = ''.join(position_labels)
    
    return position_labels

def protease_labels(protease_patterns):
    """
    Generate protease labels of format:
        "Catalytic type  -  Family  -  Protease" for all proteases with
        pre-computed patterns in MEROPS database instance.

    Parameters:
        protease_patterns -- Dict.

    Returns:
        protease_labels --
    """
    
    # Get sorted list of proteases.
    proteases = sorted(list(protease_patterns.keys()))

    # Build dictionary for hierarchical protease labeling.
    protease_groups = {}
    for protease in proteases:
        family = merops_connector.retrieve_protease_family_code(protease)
        catalytic_type = CATALYTIC_TYPES[family[0]]
        if catalytic_type in protease_groups:
            if family in protease_groups[catalytic_type]:
                protease_groups[catalytic_type][family].append(protease)
            else:
                protease_groups[catalytic_type][family] = [protease]
        else:
            protease_groups[catalytic_type] = {family: [protease]}

    # Generate sorted list of protease labels.
    protease_labels = []
    # Loop through catalytic types in alphabetical order.
    for catalytic_type in sorted(protease_groups.keys()):
        # Loop through families in alphabetical order.
        for family in sorted(protease_groups[catalytic_type].keys()):
            family_proteases = sorted(protease_groups[catalytic_type][family])
            # Generate label for each protease in family and add to list.
            protease_labels += [
                (catalytic_type.ljust(
                    len(max(protease_groups.keys(), key=len)) + 2))
                + '-  ' + family
                + '  -  ' + protease
                for protease in family_proteases
            ]
        
    return protease_labels


def generate_protease_pattern_frequency_matrix(patterns,
                                                protease_patterns,
                                                protease_labels):
    """
    Frequency matrix for pattern-protease matches.
    
    Parameters:
        patterns -- PatternContainer instance.
        protease_patterns -- Dict.
        protease_labels -- List. Protease pattern labels generated by
                            protease_labels function.

    Returns:
        frequency_matrix
    """
    frequency_matrix = [[0] * len(protease_labels)]
    for pattern in patterns:
        # Get pattern string.
        pattern_string = ''.join(pattern.character_pattern().tolist())
        # Frequency encode protease hits
        pattern_protease_vector = []
        for protease_label in protease_labels:
            # Find protease name in protease label string.
            protease = protease_label[
                (len(protease_label)
                - protease_label[::-1].find('  -  ')):].strip()
            if pattern_string in protease_patterns[protease]:
                pattern_protease_vector.append(pattern.vectorized_sequences.shape[0])
            else:
                pattern_protease_vector.append(0)
        frequency_matrix.append(pattern_protease_vector)
    
    return frequency_matrix


def generate_protease_pattern_heatmap(title,
                                        patterns,
                                        frequency_matrix,
                                        protease_labels,
                                        position_labels,
                                        output_path):         # NEED TO GET OUTPUT PATH FROM DJANGO
    """
    Generate and save pattern-to-protease heatmap.
    
    Parameters:
        title -- String.
        patterns -- PatternContainer instance.
        frequency_matrix -- List. Contains protease pattern frequencies.
        protease_labels -- List. Protease pattern labels generated by
                            protease_labels function.
        output_path -- String. Output path for heatmap SVG file.

    Returns:
        None
    """
    
    # Set up figure and axes.
    heatmap_fig = plt.figure(figsize=(24,12))
    heatmap_ax = heatmap_fig.add_subplot(111)
        
    # Generate pattern labels.
    pattern_labels = [position_labels]
    for pattern in patterns.pattern_list:
        character_pattern = pattern.character_pattern().tolist()
        pattern_label = ''
        for i, residue in enumerate(character_pattern):
            pattern_label += residue.center(5)
            # Add cleavage site indicator to even-width sequences.
            if i == ((len(character_pattern) / 2) - 1):
                pattern_label += '|'.center(5)
        pattern_labels.append(pattern_label)

    # Add dummy pattern to pattern labels and frequency matrix to
    # indicate positions.
    
    
    # Plot heatmap on axes.
    sns.heatmap(frequency_matrix,
                   cmap='Oranges',
                   xticklabels=protease_labels,
                   yticklabels=pattern_labels,
                   linewidths=0.2,
                   linecolor='#a5a091',
                   ax=heatmap_ax,
                   vmin=0.0,
                   vmax=(100.0 if (np.amax(frequency_matrix).astype(np.float64) == 0)
                            else np.amax(frequency_matrix).astype(np.float64)))
    
    # Dynamic label coloring.
    protease_pattern_frequencies = np.array(frequency_matrix,
                                            dtype='int8')
    matching_patterns = np.sum(protease_pattern_frequencies,
                               axis=1).nonzero()[0]
    detected_proteases = np.sum(protease_pattern_frequencies,
                                axis=0).nonzero()[0]
    
    # Color matching pattern labels.
    for matching_pattern in matching_patterns:
        heatmap_ax.get_yticklabels()[matching_pattern].set_color("red")
    # Color detected protease labels.
    for detected_protease in detected_proteases:
        heatmap_ax.get_xticklabels()[detected_protease].set_color("red")

    # Configure heatmap aesthetics.
    plt.setp(heatmap_ax.xaxis.get_majorticklabels(), rotation=270)
    plt.setp(heatmap_ax.yaxis.get_majorticklabels(), rotation=0)
    plt.title(title)
    plt.tight_layout()
    plt.savefig(output_path, dpi=300)